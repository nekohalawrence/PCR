name: Convert YAML Rules to List Format

on:
  push:
    branches:
      - main
    paths:
      - 'agency-resource/rule/yaml/**'
  workflow_dispatch:

jobs:
  convert:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Convert all YAML rule files to .list format
        run: |
          python - << 'EOF'
          from datetime import datetime
          from pathlib import Path
          import re

          SRC_DIR = Path("agency-resource/rule/yaml")
          DST_DIR = Path("agency-resource/rule/list")
          DST_DIR.mkdir(parents=True, exist_ok=True)

          def count_rule_types(payload_lines):
              counters = {}
              # 支持常见规则类型（可按需扩展）
              rule_pattern = re.compile(
                  r'^\s*-?\s*'
                  r'(DOMAIN|DOMAIN-SUFFIX|DOMAIN-KEYWORD|'
                  r'IP-CIDR|IP-ASN|GEOIP|'
                  r'PROCESS-NAME|SRC-IP-CIDR|DST-PORT|'
                  r'MATCH|FINAL|REJECT|DIRECT|PROXY|'
                  r'USER-AGENT|URL-REGEX)'
                  r'[,\s].*$',
                  re.IGNORECASE
              )
              for line in payload_lines:
                  line = line.strip()
                  if not line or line.startswith('#'):
                      continue
                  m = rule_pattern.match(line)
                  if m:
                      rule_type = m.group(1).upper()
                      counters[rule_type] = counters.get(rule_type, 0) + 1
              return counters

          def parse_header(lines):
              header = {}
              for line in lines:
                  line = line.strip()
                  if not line.startswith('#') or ':' not in line:
                      continue
                  try:
                      key, value = line[1:].split(':', 1)
                      header[key.strip().lower()] = value.strip()
                  except:
                      pass
              return header

          def extract_payload(lines):
              payload = []
              in_payload = False
              for line in lines:
                  s = line.rstrip()
                  if s.strip() == 'payload:':
                      in_payload = True
                      continue
                  if in_payload:
                      payload.append(s)
              return payload

          # 查找所有 yaml/yml 文件
          yaml_files = sorted(
              f for f in SRC_DIR.glob("*.[yY][aA][mM][lL]") | SRC_DIR.glob("*.[yY][mM][lL]")
              if f.is_file()
          )

          if not yaml_files:
              print("No YAML files found in agency-resource/rule/yaml/")
              exit(0)

          any_changed = False

          for src_path in yaml_files:
              try:
                  content = src_path.read_text(encoding="utf-8")
              except Exception as e:
                  print(f"Failed to read {src_path.name}: {e}")
                  continue

              lines = content.splitlines()
              header = parse_header(lines)
              payload_lines = extract_payload(lines)

              if not any(line.strip() and not line.strip().startswith('#') for line in payload_lines):
                  print(f"Skipping {src_path.name} — no meaningful payload content")
                  continue

              counters = count_rule_types(payload_lines)
              today = datetime.now().strftime("%Y%m%d")

              # 动态生成规则计数行（只包含出现过的类型）
              rule_count_lines = []
              if counters:
                  rule_count_lines = [
                      "#",
                      "# 规则计数",
                  ] + [
                      f"# {rtype:<16} {count:>3}" for rtype, count in sorted(counters.items())
                  ]

              # 构建新头部
              new_header = [
                  f"# name: {header.get('name', src_path.stem)}",
                  f"# content: {header.get('content', '').strip()}",
                  f"# update_date: {today}",
                  f"# update_url: https://raw.githubusercontent.com/${{ github.repository }}/main/{DST_DIR}/{src_path.stem}.list",
                  f"# repo: https://github.com/${{ github.repository }}/tree/main/{DST_DIR}",
                  "#",
                  "# 包含的规则",
              ]

              # 添加原始包含的规则注释（如果存在）
              if '包含的规则' in header:
                  new_header.extend(
                      f"# {l.strip()}" for l in header['包含的规则'].splitlines() if l.strip()
                  )

              new_header.extend(rule_count_lines)
              new_header.append("")

              # 组合完整内容
              output_content = "\n".join(new_header + payload_lines).rstrip() + "\n"

              dst_path = DST_DIR / f"{src_path.stem}.list"

              # 检查是否需要更新
              if dst_path.exists():
                  old_content = dst_path.read_text(encoding="utf-8")
                  if old_content == output_content:
                      print(f"No change  : {dst_path.name}")
                      continue

              dst_path.write_text(output_content, encoding="utf-8")
              print(f"Converted : {src_path.name} → {dst_path.name}")
              any_changed = True

          if not any_changed:
              print("All .list files are already up-to-date.")
          EOF

      - name: Commit and push changes (if any)
        if: always()
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          git add agency-resource/rule/list/*.list 2>/dev/null || true

          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            TODAY=$(date +%Y%m%d)
            git commit -m "chore: auto convert yaml rules to list format [${TODAY}]"
            git push
            echo "Changes committed and pushed"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
